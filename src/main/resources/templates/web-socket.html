<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>МИУ</title>
    <meta charset="UTF-8">

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Oswald:300,400,500,700|Roboto:300,400,700" rel="stylesheet">

    <!-- Stylesheets -->
    <link rel="stylesheet" href="../static/css/bootstrap.min.css" th:href="@{/css/bootstrap.min.css}"/>
    <link rel="stylesheet" href="../static/css/font-awesome.min.css" th:href="@{/css/font-awesome.min.css}"/>
    <link rel="stylesheet" href="../static/css/flaticon.css" th:href="@{/css/flaticon.css}"/>
    <link rel="stylesheet" href="../static/css/magnific-popup.css" th:href="@{/css/magnific-popup.css}"/>
    <link rel="stylesheet" href="../static/css/owl.carousel.css" th:href="@{/css/owl.carousel.css}"/>
    <link rel="stylesheet" href="../static/css/style.css" th:href="@{/css/style.css}"/>

    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>
<body>
<!-- Header section -->
<header class="header-section">
    <div class="logo" style=" font-size: 24px;">
        МИУ Современные технологии разработки web-приложений
    </div>
    <!-- Navigation -->
    <div class="responsive"><i class="fa fa-bars"></i></div>
    <nav>
        <ul class="menu-list">
            <li><a href="../miu-modern-web-technologies">Главная</a></li>
            <li><a href="../miu-modern-web-technologies/server">Сервер</a></li>
            <li><a href="../miu-modern-web-technologies/database">Базы данных</a></li>
            <li><a href="../miu-modern-web-technologies/client-server">Клиент-сервер</a></li>
            <li><a href="../miu-modern-web-technologies/html5-css3">HTML5 и CSS3</a></li>
            <li class="active"><a href="../miu-modern-web-technologies/web-socket">Веб сокеты</a></li>
        </ul>
    </nav>
</header>
<!-- Header section end -->


<!-- content section -->
<div class="about-section">
    <div class="about-contant">
        <div class="container">

            <div class="section-title">
                <h2>Здравствуйте!</h2>
            </div>

            <div class="row">
                <div class="col-md-6">
                    <h2 style="  color: white;">WebSocket</h2>
                </div>
            </div>

            <div class="row">
                <div class="col-md-12">
                    <h3 style="  color: white;">Введение</h3>
                    <p>WebSocket — протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между
                        браузером и веб-сервером в режиме реального времени.

                        В настоящее время в W3C осуществляется стандартизация API Web Sockets. Черновой вариант
                        стандарта этого протокола утверждён IETF.

                        WebSocket разработан для воплощения в веб-браузерах и веб-серверах, но он может быть использован
                        для любого клиентского или серверного приложения. Протокол WebSocket — это независимый протокол,
                        основанный на протоколе TCP. Он делает возможным более тесное взаимодействие между браузером и
                        веб-сайтом, способствуя распространению интерактивного содержимого и созданию приложений
                        реального времени.</p>
                </div>
            </div>


            <div class="row">
                <div class="col-md-12">
                    <p>Пример браузерного кода
                        Для открытия соединения достаточно создать объект WebSocket, указав в нём специальный протокол
                        ws.:

                        var socket = new WebSocket("ws://javascript.ru/ws");
                        У объекта socket есть четыре коллбэка: один при получении данных и три – при изменениях в
                        состоянии соединения:


                        socket.onopen = function() {
                        alert("Соединение установлено.");
                        };

                        socket.onclose = function(event) {
                        if (event.wasClean) {
                        alert('Соединение закрыто чисто');
                        } else {
                        alert('Обрыв соединения'); // например, "убит" процесс сервера
                        }
                        alert('Код: ' + event.code + ' причина: ' + event.reason);
                        };

                        socket.onmessage = function(event) {
                        alert("Получены данные " + event.data);
                        };

                        socket.onerror = function(error) {
                        alert("Ошибка " + error.message);
                        };
                        Для посылки данных используется метод socket.send(data). Пересылать можно любые данные.

                        Например, строку:

                        socket.send("Привет");
                        …Или файл, выбранный в форме:

                        socket.send(form.elements[0].file);
                        Просто, не правда ли? Выбираем, что переслать, и socket.send().

                        Для того, чтобы коммуникация была успешной, сервер должен поддерживать протокол WebSocket.

                        Чтобы лучше понимать происходящее – посмотрим, как он устроен.

                        Установление WebSocket-соединения
                        Протокол WebSocket работает над TCP.

                        Это означает, что при соединении браузер отправляет по HTTP специальные заголовки, спрашивая:
                        «поддерживает ли сервер WebSocket?».

                        Если сервер в ответных заголовках отвечает «да, поддерживаю», то дальше HTTP прекращается и
                        общение идёт на специальном протоколе WebSocket, который уже не имеет с HTTP ничего общего.

                        Установление соединения
                        Пример запроса от браузера при создании нового объекта new
                        WebSocket("ws://server.example.com/chat"):

                        GET /chat HTTP/1.1
                        Host: server.example.com
                        Upgrade: websocket
                        Connection: Upgrade
                        Origin: http://javascript.ru
                        Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
                        Sec-WebSocket-Version: 13
                        Описания заголовков:

                        GET, Host
                        Стандартные HTTP-заголовки из URL запроса
                        Upgrade, Connection
                        Указывают, что браузер хочет перейти на websocket.
                        Origin
                        Протокол, домен и порт, откуда отправлен запрос.
                        Sec-WebSocket-Key
                        Случайный ключ, который генерируется браузером: 16 байт в кодировке Base64.
                        Sec-WebSocket-Version
                        Версия протокола. Текущая версия: 13.
                        Все заголовки, кроме GET и Host, браузер генерирует сам, без возможности вмешательства
                        JavaScript.

                        Такой XMLHttpRequest создать нельзя
                        Создать подобный XMLHttpRequest-запрос (подделать WebSocket) невозможно, по одной простой
                        причине: указанные выше заголовки запрещены к установке методом setRequestHeader.

                        Сервер может проанализировать эти заголовки и решить, разрешает ли он WebSocket с данного домена
                        Origin.

                        Ответ сервера, если он понимает и разрешает WebSocket-подключение:

                        HTTP/1.1 101 Switching Protocols
                        Upgrade: websocket
                        Connection: Upgrade
                        Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
                        Здесь строка Sec-WebSocket-Accept представляет собой перекодированный по специальному алгоритму
                        ключ Sec-WebSocket-Key. Браузер использует её для проверки, что ответ предназначается именно
                        ему.

                        Затем данные передаются по специальному протоколу, структура которого («фреймы») изложена далее.
                        И это уже совсем не HTTP.

                        Расширения и подпротоколы
                        Также возможны дополнительные заголовки Sec-WebSocket-Extensions и Sec-WebSocket-Protocol,
                        описывающие расширения и подпротоколы (subprotocol), которые поддерживает данный клиент.

                        Посмотрим разницу между ними на двух примерах:

                        Заголовок Sec-WebSocket-Extensions: deflate-frame означает, что браузер поддерживает модификацию
                        протокола, обеспечивающую сжатие данных.

                        Это говорит не о самих данных, а об улучшении способа их передачи. Браузер сам формирует этот
                        заголовок.

                        Заголовок Sec-WebSocket-Protocol: soap, wamp говорит о том, что по WebSocket браузер собирается
                        передавать не просто какие-то данные, а данные в протоколах SOAP или WAMP («The WebSocket
                        Application Messaging Protocol»). Стандартные подпротоколы регистрируются в специальном каталоге
                        IANA.

                        Этот заголовок браузер поставит, если указать второй необязательный параметр WebSocket:

                        var socket = new WebSocket("ws://javascript.ru/ws", ["soap", "wamp"]);
                        При наличии таких заголовков сервер может выбрать расширения и подпротоколы, которые он
                        поддерживает, и ответить с ними.

                        Например, запрос:


                        GET /chat HTTP/1.1
                        Host: server.example.com
                        Upgrade: websocket
                        Connection: Upgrade
                        Origin: http://javascript.ru
                        Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
                        Sec-WebSocket-Version: 13
                        Sec-WebSocket-Extensions: deflate-frame
                        Sec-WebSocket-Protocol: soap, wamp
                        Ответ:


                        HTTP/1.1 101 Switching Protocols
                        Upgrade: websocket
                        Connection: Upgrade
                        Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
                        Sec-WebSocket-Extensions: deflate-frame
                        Sec-WebSocket-Protocol: soap
                        В ответе выше сервер указывает, что поддерживает расширение deflate-frame, а из запрошенных
                        подпротоколов – только SOAP.

                        WSS
                        Соединение WebSocket можно открывать как WS:// или как WSS://. Протокол WSS представляет собой
                        WebSocket над HTTPS.

                        Кроме большей безопасности, у WSS есть важное преимущество перед обычным WS – большая
                        вероятность соединения.

                        Дело в том, что HTTPS шифрует трафик от клиента к серверу, а HTTP – нет.

                        Если между клиентом и сервером есть прокси, то в случае с HTTP все WebSocket-заголовки и данные
                        передаются через него. Прокси имеет к ним доступ, ведь они никак не шифруются, и может расценить
                        происходящее как нарушение протокола HTTP, обрезать заголовки или оборвать передачу.

                        А в случае с WSS весь трафик сразу кодируется и через прокси проходит уже в закодированном виде.
                        Поэтому заголовки гарантированно пройдут, и общая вероятность соединения через WSS выше, чем
                        через WS.

                        Формат данных
                        Полное описание протокола содержится в RFC 6455.

                        Здесь представлено частичное описание с комментариями самых важных его частей. Если вы хотите
                        понять стандарт, то рекомендуется сначала прочитать это описание.

                        Описание фрейма
                        В протоколе WebSocket предусмотрены несколько видов пакетов («фреймов»).

                        Они делятся на два больших типа: фреймы с данными («data frames») и управляющие («control
                        frames»), предназначенные для проверки связи (PING) и закрытия соединения.

                        Фрейм, согласно стандарту, выглядит так:

                        0 1 2 3
                        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                        +-+-+-+-+-------+-+-------------+-------------------------------+
                        |F|R|R|R| опкод |М| Длина тела | Расширенная длина тела |
                        |I|S|S|S|(4бита)|А| (7бит) | (1 байт) |
                        |N|V|V|V| |С| |(если длина тела==126 или 127) |
                        | |1|2|3| |К| | |
                        | | | | | |А| | |
                        +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
                        | Продолжение расширенной длины тела, если длина тела = 127 |
                        + - - - - - - - - - - - - - - - +-------------------------------+
                        | | Ключ маски, если МАСКА = 1 |
                        +-------------------------------+-------------------------------+
                        | Ключ маски (продолжение) | Данные фрейма ("тело") |
                        +-------------------------------- - - - - - - - - - - - - - - - +
                        : Данные продолжаются ... :
                        + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
                        | Данные продолжаются ... |
                        +---------------------------------------------------------------+
                        С виду – не очень понятно, во всяком случае, для большинства людей.

                        Позвольте пояснить: читать следует слева-направо, сверху-вниз, каждая горизонтальная полоска это
                        32 бита.

                        То есть, вот первые 32 бита:

                        0 1 2 3
                        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                        +-+-+-+-+-------+-+-------------+-------------------------------+
                        |F|R|R|R| опкод |М| Длина тела | Расширенная длина тела |
                        |I|S|S|S|(4бита)|А| (7бит) | (1 байт) |
                        |N|V|V|V| |С| |(если длина тела==126 или 127) |
                        | |1|2|3| |К| | |
                        | | | | | |А| | |
                        +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
                        Сначала идёт бит FIN (вертикальная надпись на рисунке), затем биты RSV1, RSV2, RSV3 (их смысл
                        раскрыт ниже), затем «опкод», «МАСКА» и, наконец, «Длина тела», которая занимает 7 бит. Затем,
                        если «Длина тела» равна 126 или 127, идёт «Расширенная длина тела», потом (на следующей строке,
                        то есть после первых 32 бит) будет её продолжение, ключ маски, и потом данные.

                        А теперь – подробное описание частей фрейма, то есть как именно передаются сообщения:

                        FIN: 1 бит
                        Одно сообщение, если оно очень длинное (вызовом send можно передать хоть целый файл), может
                        состоять из множества фреймов («быть фрагментированным»).

                        У всех фреймов, кроме последнего, этот фрагмент установлен в 0, у последнего – в 1.

                        Если сообщение состоит из одного-единственного фрейма, то FIN в нём равен 1.

                        RSV1, RSV2, RSV3: 1 бит каждый
                        В обычном WebSocket равны 0, предназначены для расширений протокола. Расширение может записать в
                        эти биты свои значения.

                        Опкод: 4 бита
                        Задаёт тип фрейма, который позволяет интерпретировать находящиеся в нём данные. Возможные
                        значения:

                        0x1 обозначает текстовый фрейм.
                        0x2 обозначает двоичный фрейм.
                        0x3-7 зарезервированы для будущих фреймов с данными.
                        0x8 обозначает закрытие соединения этим фреймом.
                        0x9 обозначает PING.
                        0xA обозначает PONG.
                        0xB-F зарезервированы для будущих управляющих фреймов.
                        0x0 обозначает фрейм-продолжение для фрагментированного сообщения. Он интерпретируется, исходя
                        из ближайшего предыдущего ненулевого типа.
                        Маска: 1 бит
                        Если этот бит установлен, то данные фрейма маскированы. Более подробно маску и маскирование мы
                        рассмотрим далее.

                        Длина тела: 7 битов, 7+16 битов, или 7+64 битов
                        Если значение поле «Длина тела» лежит в интервале 0-125, то оно обозначает длину тела
                        (используется далее). Если 126, то следующие 2 байта интерпретируются как 16-битное беззнаковое
                        целое число, содержащее длину тела. Если 127, то следующие 8 байт интерпретируются как 64-битное
                        беззнаковое целое, содержащее длину.

                        Такая хитрая схема нужна, чтобы минимизировать накладные расходы. Для сообщений длиной 125 байт
                        и меньше хранение длины потребует всего 7 битов, для бóльших (до 65536) – 7 битов + 2 байта, ну
                        а для ещё бóльших – 7 битов и 8 байт. Этого хватит для хранения длины сообщения размером в
                        гигабайт и более.

                        Ключ маски: 4 байта.
                        Если бит Маска установлен в 0, то этого поля нет. Если в 1 то эти байты содержат маску, которая
                        налагается на тело (см. далее).

                        Данные фрейма (тело)
                        Состоит из «данных расширений» и «данных приложения», которые идут за ними. Данные расширений
                        определяются конкретными расширениями протокола и по умолчанию отсутствуют. Длина тела должна
                        быть равна указанной в заголовке.

                        Примеры
                        Некоторые примеры сообщений:

                        Нефрагментированное текстовое сообщение Hello без маски:

                        0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (содержит "Hello")
                        В заголовке первый байт содержит FIN=1 и опкод=0x1 (получается 10000001 в двоичной системе, то
                        есть 0x81 – в 16-ричной), далее идёт длина 0x5, далее текст.

                        Фрагментированное текстовое сообщение Hello World из трёх частей, без маски, может выглядеть
                        так:

                        0x01 0x05 0x48 0x65 0x6c 0x6c 0x6f (содержит "Hello")
                        0x00 0x01 0x20 (содержит " ")
                        0x80 0x05 0x57 0x6f 0x72 0x6c 0x64 (содержит "World")
                        У первого фрейма FIN=0 и текстовый опкод 0x1.
                        У второго FIN=0 и опкод 0x0. При фрагментации сообщения, у всех фреймов, кроме первого, опкод
                        пустой (он один на всё сообщение).
                        У третьего, последнего фрейма FIN=1.
                        А теперь посмотрим на все те замечательные возможности, которые даёт этот формат фрейма.

                        Фрагментация
                        Позволяет отправлять сообщения в тех случаях, когда на момент начала посылки полный размер ещё
                        неизвестен.

                        Например, идёт поиск в базе данных и что-то уже найдено, а что-то ещё может быть позже.

                        У всех сообщений, кроме последнего, бит FIN=0.
                        Опкод указывается только у первого, у остальных он должен быть равен 0x0.
                        PING / PONG
                        В протокол встроена проверка связи при помощи управляющих фреймов типа PING и PONG.

                        Тот, кто хочет проверить соединение, отправляет фрейм PING с произвольным телом. Его получатель
                        должен в разумное время ответить фреймом PONG с тем же телом.

                        Этот функционал встроен в браузерную реализацию, так что браузер ответит на PING сервера, но
                        управлять им из JavaScript нельзя.

                        Иначе говоря, сервер всегда знает, жив ли посетитель или у него проблема с сетью.

                        Чистое закрытие
                        При закрытии соединения сторона, желающая это сделать (обе стороны в WebSocket равноправны)
                        отправляет закрывающий фрейм (опкод 0x8), в теле которого указывает причину закрытия.

                        В браузерной реализации эта причина будет содержаться в свойстве reason события onclose.

                        Наличие такого фрейма позволяет отличить «чистое закрытие» от обрыва связи.

                        В браузерной реализации событие onclose при чистом закрытии имеет event.wasClean = true.

                        Коды закрытия
                        Коды закрытия вебсокета event.code, чтобы не путать их с HTTP-кодами, состоят из 4 цифр:

                        1000
                        Нормальное закрытие.
                        1001
                        Удалённая сторона «исчезла». Например, процесс сервера убит или браузер перешёл на другую
                        страницу.
                        1002
                        Удалённая сторона завершила соединение в связи с ошибкой протокола.
                        1003
                        Удалённая сторона завершила соединение в связи с тем, что она получила данные, которые не может
                        принять. Например, сторона, которая понимает только текстовые данные, может закрыть соединение с
                        таким кодом, если приняла бинарное сообщение.</p>
                </div>
            </div>


            <div class="row">
                <div class="col-md-12">
                    <h3 style="  color: white;">WebRTC</h3>
                    <p>
                        WebRTC (англ. real-time communications — коммуникации в реальном времени) — проект с открытым
                        исходным кодом, предназначенный для организации передачи потоковых данных между браузерами или
                        другими поддерживающими его приложениями по технологии точка-точка.

                        На уровне API технология стандартизируется консорциумом W3C, а на протокольном уровне —
                        сообществом IETF[1]. Его включение в рекомендации W3C поддерживается Google Chrome (и других на
                        его основе), Mozilla и Opera[2][3][4].

                        WebRTC распространяется по лицензии BSD-3 и исходный код основывается на продукте от Global IP
                        Solution, которая была куплена компанией Google в мае 2010
                    </p>
                    <div><p>Технология</p></div>

                    <div><p> Технология WebRTC делает возможной видеосвязь через окно браузера, так что для
                        присоединения к звонку необходимо только перейти по ссылке на соответствующую веб-страницу.[7]

                        В WebRTC используются два аудиокодека, G.711 и Opus, а также видеокодеки VP8 и H.264.[8]
                    </p></div>

                    <div><p> Преимущества технологии
                        проведение конференции в браузере значительно упрощает процесс проведения конференции —
                        пользователю не нужно устанавливать для этого отдельные приложения;
                        используемые кодеки обеспечивают хорошее качество связи;
                        возможность реализации любых элементов интерфейса средствами HTML5 и JavaScript;
                        открытый исходный код даёт больше возможностей для использования.</p></div>
                    <div><p> Недостатки технологии
                        технология определяет только общий стандарт передачи данных (видео и звука), но отдельные
                        решения разных браузеров относительно адресации абонентов и прочих управляющих процессов не
                        совместимы между собой. Поэтому даже звонки между парой различных браузеров представляют
                        отдельную сложность.[9][10][11]
                        обеспечение групповых конференций требует дополнительных разработок поверх WebRTC.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- content section end -->


<!-- Footer section -->
<footer class="footer-section">
    <h2>2019 All rights reserved. Done by <a href="https://github.com/llka" target="_blank">Ilya Kisel</a></h2>
</footer>
<!-- Footer section end -->


<!--====== Javascripts & Jquery ======-->
<script type="text/javascript" src="../static/js/jquery-2.1.4.min.js" th:src="@{/js/jquery-2.1.4.min.js}"></script>
<script type="text/javascript" src="../static/js/bootstrap.min.js" th:src="@{/js/bootstrap.min.js}"></script>
<script type="text/javascript" src="../static/js/magnific-popup.min.js"
        th:src="@{/js/magnific-popup.min.js}"></script>
<script type="text/javascript" src="../static/js/owl.carousel.min.js" th:src="@{/js/owl.carousel.min.js}"></script>
<script type="text/javascript" src="../static/js/circle-progress.min.js"
        th:src="@{/js/circle-progress.min.js}"></script>
<script type="text/javascript" src="../static/js/main.js" th:src="@{/js/main.js}"></script>

</body>
</html>
